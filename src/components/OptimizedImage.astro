---
interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  className?: string;
  loading?: 'lazy' | 'eager';
  fetchpriority?: 'high' | 'low' | 'auto';
  sizes?: string;
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  type?: 'hero' | 'content' | 'thumbnail' | 'logo'; // Tipo de imagen para determinar tamaños
}

const {
  src,
  alt,
  width,
  height,
  className = '',
  loading = 'lazy',
  fetchpriority = 'auto',
  sizes,
  objectFit = 'cover',
  type
} = Astro.props;

// Detectar si es imagen LCP (generalmente la primera imagen del hero)
const isLCP = loading === 'eager' && fetchpriority === 'high';

// Determinar tamaños según tipo de imagen o inferir del src
const determineSizes = () => {
  if (type) {
    switch (type) {
      case 'hero':
        return [800, 1200, 1600, 1920];
      case 'thumbnail':
      case 'logo':
        return [200, 400, 600];
      case 'content':
      default:
        return [400, 600, 800, 1200];
    }
  }
  
  // Auto-detectar según ruta
  const srcLower = src.toLowerCase();
  if (srcLower.includes('hero') || srcLower.includes('gemini_generated_image')) {
    return [800, 1200, 1600, 1920];
  }
  if (srcLower.includes('logo') || srcLower.includes('cliente') || srcLower.includes('marca')) {
    return [200, 400, 600];
  }
  return [400, 600, 800, 1200];
};

const sizes_for_srcset = determineSizes();

// Determinar sizes attribute si no se proporciona
const sizesAttribute = sizes || (
  type === 'hero' ? '100vw' :
  type === 'logo' || type === 'thumbnail' ? '(max-width: 768px) 150px, 150px' :
  '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw'
);

// Generar rutas WebP
const getWebPPath = (originalPath: string, size?: number) => {
  const ext = originalPath.match(/\.(jpg|jpeg|png|webp)$/i)?.[0] || '';
  const basePath = originalPath.replace(/\.(jpg|jpeg|png|webp)$/i, '');
  const sizeSuffix = size ? `-${size}w` : '';
  return `${basePath}${sizeSuffix}.webp`;
};

// Generar srcset para WebP
const webpSrcset = sizes_for_srcset
  .map((size) => {
    const webpPath = getWebPPath(src, size);
    return `${encodeURI(webpPath)} ${size}w`;
  })
  .filter(Boolean)
  .join(', ');

// Fallback srcset para formatos originales
const fallbackSrcset = sizes_for_srcset
  .map((size) => {
    return `${encodeURI(src)} ${size}w`;
  })
  .filter(Boolean)
  .join(', ');

// Aspect ratio para evitar CLS
const aspectRatio = width && height ? `${width} / ${height}` : undefined;
const aspectRatioStyle = aspectRatio ? `aspect-ratio: ${aspectRatio};` : '';
---

<picture>
  <!-- WebP con srcset - Se intentará cargar, pero si no existe usará fallback -->
  {webpSrcset && (
    <source
      srcset={webpSrcset}
      sizes={sizesAttribute}
      type="image/webp"
    />
  )}
  
  <!-- Fallback con srcset -->
  {fallbackSrcset && (
    <source
      srcset={fallbackSrcset}
      sizes={sizesAttribute}
      type={src.match(/\.(jpg|jpeg)$/i) ? 'image/jpeg' : 'image/png'}
    />
  )}
  
  <!-- Imagen fallback - SIEMPRE se muestra si WebP falla -->
  <img
    src={src}
    alt={alt}
    width={width}
    height={height}
    loading={loading}
    fetchpriority={fetchpriority}
    decoding={isLCP ? 'sync' : 'async'}
    class={className}
    style={`
      ${aspectRatioStyle}
      object-fit: ${objectFit};
      ${width ? `max-width: ${width}px;` : ''}
      ${height ? `max-height: ${height}px;` : ''}
    `}
    sizes={sizesAttribute}
  />
</picture>

